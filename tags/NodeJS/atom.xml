<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: NodeJS | Thinking in Crowd / 鹄思乱想]]></title>
  <link href="http://www.thinkingincrowd.me/tags/nodejs/atom.xml" rel="self"/>
  <link href="http://www.thinkingincrowd.me/"/>
  <updated>2014-03-30T09:44:43+08:00</updated>
  <id>http://www.thinkingincrowd.me/</id>
  <author>
    <name><![CDATA[鹄思乱想]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[京JS 2013 之挖坑自埋与神打击]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/11/14/jingjs-2013-fun/"/>
    <updated>2013-11-14T20:21:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/11/14/jingjs-2013-fun</id>
    <content type="html"><![CDATA[<p><img alt="JingJS Badge" src="http://thinkingincrowd.u.qiniudn.com/JingJS_Badge.jpg?imageView/2/w/100" style="position: relative; float: left; margin-right: 5px; border: 0px;"/>首先要吐槽一下 <a href="http://weibo.com/jingjs2013">@京JS</a>。指示牌不清楚，从酒店另一个门进去根本看不到，最悲剧的是酒店的服务员都不知道这个会议。还有就是硬件上相当不给力，没有 WIFI，这不是新10大酷刑之一吗？没午饭，还要我等外地屌丝奔波找吃的。加之第一天的讲座广告水份有点多，个人感觉有趣的和比较好的是 <a href="https://github.com/substack">@substack</a>，<a href="http://isaacmao.com/">Issac</a> 和讲 Data Visualization 的 Nick。第二天早上的主题还是相当给力的，下午 Kim, Jakob 也还不错。</p>

<p>晚上的活动还是要狠狠表扬一下 @京JS。第一晚包了车库咖啡，晚饭虽然是 Pizza 等，但是量也算足，只是地方有点小，不过也是逼着和别人站着交流的好机会。星期天的晚上还有去 Bar 的 after-party，可惜我要赶飞机回珠海，就没法去了，但估计也会很棒。</p>

<p>第一天晚上，看到 @substack 来了后，我坚定不移地过去和他搭话，接着各种好玩，技术黑和大神间（当然这不包我）的对话就来了。首先声明，可以肯定我的智商是完全没法跟上大神的，加上没法肯定听力上能跟上多少。所以下面的一些神吐糟不保证 100％ 正确，有错误的话也是我这译者的错误，并且这里的技术黑都不是拉仇恨啊。 Please forgive my poor English for any potential misleading.</p>

<p>我和他搭话是因为我最近看的一篇<a href="http://www.thinkingincrowd.me/blog/2013/11/13/callbacks-are-imperative/">关于 Promise 的文章</a>，个人感觉不错的，想问他对比 Callback 有什么看法。原来他并不太喜欢 Promise。（好了，整晚挖坑自埋的节奏开始了）。他指点我去看看 <a href="http://callbackhell.com">callbackhell.com</a>，还有他的 <a href="https://github.com/substack/stream-handbook">stream-handbook</a>。说如果我按照那样做了，也应该不会碰到什么 Hell 的问题。他说即使他以后遇到，也是首先偏向于用 <a href="https://github.com/caolan/async">Async</a> 的。</p>

<p><img alt="Substack Signature" src="http://thinkingincrowd.u.qiniudn.com/Substack_Signature.jpg?imageView/2/w/500" style="border: 0px;"/></p>

<p>接着一个同学拿着 Douglas Crockford 的书给他签名，他说虽然和他有点过节还是观点不同什么来着（他用的词忘了），但还是签了（他的签名很有趣，就是上面这幅机器人漫画，幸亏我也拿到一个）。我就八卦了一下问是他说的是什么情况，他举例说那个什么 <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">Hoisting</a> 就是胡扯。我当然也很赞同的说是的，应该定义在离它最近使用的地方。好像记得 <a href="http://weibo.com/lifesinger">@玉伯也叫射雕</a> 也是持同样观点的。</p>

<p>然后 <a href="http://weibo.com/fool2fish">@fool2fish</a> 出现了，问他关于一些测试方面怎么区分浏览器 Tab 独立线程，监测 CPU，等什么的（好像是说这些吧，中间没太跟上）。然后他不断解说和演示他的 <a href="https://github.com/substack/testling">testling</a> 可以拿来怎么用。</p>

<p>之后 @fool2fish 就问可以在 testling 里用什么测试框架，@substack 又把自己的 <a href="https://github.com/substack/tape">tape</a> 搬出来耍了。@fool2fish 再问能否集成 <a href="https://github.com/visionmedia/mocha">Mocha</a> 之类的框架时，@substack 说可以的。但是他不喜欢用那些框架，一堆的全局变量，evil，不是 Node 可以直接运行的程序。还有 <a href="https://github.com/pivotal/jasmine">Jasmine</a> 什么的更烂。估计喜欢这两个的，听到这都晕了。</p>

<p>然后转到问是否支持 <a href="http://en.wikipedia.org/wiki/Asynchronous_module_definition">AMD</a>，<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a> 的主题上。@fool2fish 就给他瞄了一眼 <a href="https://github.com/seajs/seajs">SeaJS</a> define 的用法，可能本想把它推出国门。没想到他说他知道 SeaJS，但这不是 CommonJS，是 fake 的写法。@fool2fish 脸都绿了，都想拉 @玉伯也叫射雕 来抵抗一下了，没等反应过来。@substack 又搬出了他的 <a href="https://github.com/substack/node-browserify">browserify</a> 来说明怎么把 Node 的代码和浏览器分享（这个观点我一直是比较赞同的，所以之前也基于 <a href="https://github.com/medikoo/modules-webmake">webmake</a> 搞了个 <a href="https://github.com/kenspirit/webassemble">webassemble</a>。因为我觉的生产环境基本都是打包好再用的，哪有什么异步再去拿文件，异步也是拿另一个大 bundle。require 在 Node 的写法，如果在浏览器能通用确实挺好的。回头细想是不是偏后端程序员没看到前端看到的另一些东西，我再想想）。旁边的另一个鬼佬（抱歉不认识是哪位神），看到我们被打击的样子，几乎笑的不行了，都和 @substack 说你别再打击他们了，可是神才不鸟你，继续打击。</p>

<p>后面，他们都走了，我犯贱又去问 @substack 怎么看那些前端的 MVC 或者 MVVM 的框架，比如 <a href="http://angularjs.org">AngularJS</a>。他说他还没看懂到底它最终要解决什么问题，一堆的东西，什么 DI，Databinding 等。我说 Databinding 很好啊，可以免得我们写一堆代码拿值赋值等，declarative 语法也不错啊。他说他只是写纯粹的 JS，那些拿值赋值的可以什么把原生操作抽象和模块化，举例说把复杂的 Form 抽象成模块，只在里头处理赋值拿值之类的。我说那不是 JS 和 HTML 混一起了吗？他好像说只要模块化的好就没有问题了。晕。（这里不敢苟同，可能我还没到那种境界）</p>

<p>最后，又再一次嘴贱的问他那个 tape 能不能集成到 <a href="http://gruntjs.com/%E2%80%8E">Grunt</a>。没想到他说他也没看明白 Grunt 有什么用，我就知道我又挖坑埋自己了。他啪啪啪敲键盘和让我看他怎么用 NPM 的 test 命令，自定义命令和直接结合 Script 来做到一系列的集成操作的。</p>

<p>@substack 真是 geek 到不行啊。他追求纯粹，简洁，和模块化可以说到极致的境地，不喜欢那些大而全的框架，真的是和我最近看的 “Art of Unit Programming” 那本书说到 “Only do one thing and do it really well”，然后通过组合把一些小工具结合成更强大的工具的思想非常吻合。</p>

<p>后面 H神 来了之后，被打击对象转到他头上了。是的，神喷神了，哈哈。以下可能和原话有偏差，因为大神间的对话，我有时实在很难跟上。</p>

<p>H神 在做的是 <a href="http://vertx.io/">Vert.x</a>。他一开始说它们直接支持在 npm 跑还是改了加了什么新功能来着。（一开始我在纠结那个 Vertx 发音是什么东西，迷失了一下）。@substack 就说你们那么改的原因是什么？带来什么好处？没好处改来干什么？（另一个神被打击的样子很有趣 :D ）。后来说 Vert.x 特性是 Polyglot，说到支持 Java，Python 等，@substack 意思好像是说为什么要那么做？那些垃圾语言支持来干嘛？（Python 差点被拖累了，他后来改口说 Python 不烂）我永远都不要写 JAVA。H神 也脸绿了，我也帮口说在商业大项目里，因为系统和团队的多和杂，Polyglot 和 JAVA 都是需要的，虽然我现在也不喜欢 JAVA。其实无论我们怎么说，神的观点都不会变，他就说我不会遇到这样的情况，哈哈。H神 后来问 @substack Vert.x 怎么才能被他们 buyin (接受)，@substack 就不断 blablabla 说什么你们的 api 要保持和 npm 一致，要在 npm 上容易安装，可以通过 -g 参数那样装了后，命令运行等，不然你看现在没人鸟你们，然后各种建议给他。</p>

<p>两大神后来开始缅怀小时候几岁的时候玩什么技术之类的，我的智商和听力就彻底跟不上了。后来 H神 说他用 SQL 去考他妈妈，他妈妈竟然只需要问它那个语句是干什么的，然后她妈妈竟然可以从汇编，指令和寄存器的角度指出它哪里有问题了。靠，开挂了吧。H神 还想请 @substack 去他们上海公司给员工感受一下什么叫做 live for code，而不是 code for live 的精神。说费用他包，问有没有兴趣。@substack 好像说会在中国待 3 星期，没什么问题，之后可能还要到深圳来骑车什么的。深圳的同学们有关系的话，就看能不能请到他去玩了。后面我们扯着扯着就讲到为什么国内那么难找到这样的人，什么独生政策，教育，压力的都来了。中间我还讥讽 H神 也还不是 code for live。他说不是，他是因为写 code 是让他可以赚最多钱的工作。其实他还可以搞建筑什么的，还说他的床上功夫也不错，笑死我。 我们就这样一直聊到 10 点散场了才走了。</p>

<p>整个晚上和 @substack 及其他大神的一些直接对话真比在会场听一天感悟还多。所以意见是大家以后听会议，一定要准备问题，尽量和各种大神聊天。只是听讲座和拍几张PPT或大神照片就没什么用了。</p>

<p><img alt="Group" src="http://thinkingincrowd.u.qiniudn.com/JingJS_AfterParty.JPG?imageView/2/w/500" style="border: 0px;"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回调函数是指令式的，Promise 是函数式的：Node 错失的最大机会]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/11/13/callbacks-are-imperative/"/>
    <updated>2013-11-13T21:43:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/11/13/callbacks-are-imperative</id>
    <content type="html"><![CDATA[<p>我之前都有接触过关于 <a href="http://en.wikipedia.org/wiki/Promise_(programming)">Promise</a> 的一些文章，但是对它的感觉并不大。因为觉得虽然<a href="http://en.wikipedia.org/wiki/Callback_(computer_programming)">回调</a>风格确实有问题，但我写的代码还没有复杂到那种程度，所以，要去使用的感觉并不强烈。</p>

<p>但是，后面碰到一个问题真的好像用回调的风格来写的话，会比较糟糕。加上看到了这一篇从另一侧面来看 Promise 对函数式编程的思维方面的转变，觉得很不错。值得一看，所以在有其它大神也翻译过的情况下，自己也译一次，顺便深入学习。</p>

<p>原文链接： <a href="http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/">Callbacks are imperative, promises are functional: Node’s biggest missed opportunity</a></p>

<blockquote><p>Promise的本质就是他们不随着环境的变化而变化。</p>

<p>  —— Frank Underwood，‘纸牌屋’</p></blockquote>

<p>你经常会听到说 JavaScript 是一门 &ldquo;函数式&rdquo; 编程语言。通常我们这样描述它的时候是因为函数在它里面是作为 &ldquo;一等公民&rdquo; 而存在的。但是其它 &ldquo;函数式&rdquo; 编程语言里面的特性，比如：数据不可改变，代数类型系统，使用迭代优于循环，避免副作用都统统忽略了。虽然函数作为 &ldquo;一等公民&rdquo; 是非常有用的，并且决定用户能够在需要的时候使用函数式风格来编写代码。但是 JS 是函数式的观点却常常忽略了函数式编程的核心思想：面向值编程。</p>

<p>&ldquo;函数式编程&rdquo; 的命名其实会产生误导，以至于人们认为它的意义在于，相对于 “面向对象编程” 来说，它是 “面向函数编程”。但是如果面向对象编程是把所有东西都从对象角度考虑，那函数式编程就是把所有东西都作为值来处理，而不仅仅是把函数考虑为值。很明显，数值当然包含那些数字，字符，列表和其它数据值，但其实它也包含其它面向对象编程的粉丝通常没有考虑过的一些东西：IO 操作和其它副作用，GUI 事件流，空值检查，甚至函数调用的顺序。如果你曾经听说过 “<a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">可编程分号</a>” 的话，你应该知道我想说的是什么了.</p>

<p>函数式编程最大的好处是它是声明式的。在命令式编程里面，我们需要写一系列的指令来告诉计算机是怎么去实现我们想要做的事情的。在函数式编程里面，我们只是需要描述值之间的计算关系，计算机就会自己想办法得出需要的计算指令顺序。</p>

<p>如果你使用过 Excel 的话，你其实已经用过函数式编程了：你只需要描述一个图表里面的值，是怎么相互计算出来的。当有新数据插入的时候，Excel 就会自己得出图表里有什么地方的值和效果要更新，而你并不需要再为它写出任何指令，它也可以帮你计算出来。</p>

<p>在阐述了这些基本概念的基础上，我想说明一下我觉得 Node.js 在设计上最大的失误是什么: 这就是在它的设计早期，决定了倾向于使用回调风格的 API 而不是 promise 风格.</p>

<blockquote><p>所有人都使用回调。如果你发布了一个返回 promise 的模块，根本没有人会关注和使用你那个模块。</p>

<p>如果我写了一个小模块，它需要和 Redis 交互，我所需要做的唯一一件事情就是传递一个回调函数给 Redis。当我们遇到<a href="http://callbackhell.com/">回调无底洞</a>的时候，其实这根本不是什么问题: 因为同样有<a href="http://en.wikipedia.org/wiki/Coroutine">协程</a>和 <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">monad</a> 无底洞。因为如果你把任何一个抽象使用地足够频繁的话，都同样会创造一个无底洞。</p>

<p>在 90% 的情况下，你只需要做一件事情，回调如此简单的接口使得你只是需要简单的缩进一下就可以了。如果你遇到了非常复杂的用例，你和其它在 npm 里面的 827 个模块一样，使用 async 就好了.</p>

<p>—— Mikeal Rogers，LXJS 2012</p></blockquote>

<p>这段话是从 Mikeal Rogers 最近的一次涵盖了好些 Node 设计哲学的演讲里摘取出来的:</p>

<blockquote><p>在 Node 的初期设计目标里面，我希望可以让更多的非专家级别的程序员可以很容易编写出快速，支持并行的网络程序，虽然我知道这个想法有点违背生产效率。Promises 其实可以使得程序在运行时自动控制数据流动，而不是靠程序员通过显式指令控制，所以能更加容易组织正确清晰和最大化并行操作的程序.</p></blockquote>

<p>要写出正确的并行程序基本上需要你实现尽可能多的并行工作的同时，保证操作指令还是以正确的顺序执行。虽然 JavaScript 是单线程的，但我们依然有可能因为在异步操作的情况下触发了竞争机制: 任何涉及 IO 的操作都会在它等待回调的时候把 CPU 时间腾到其它操作上面。多个并发操作就有可能同时访问同一段内存数据，或者产生一系列重叠的操作数据库或者 DOM 的指令。所以，我希望在这篇文章里可以告诉大家，promies 能够像 Excel 一样，提供一种只需要描述值之间的关系模型，你的工具就能够自动寻求最佳解决方案给你。而不是需要你自己控制程序流.</p>

<p>我希望可以清除掉一个误区就是 promises 的使用就是为了让语法结构看起来比基于回调的异步操作更清晰。其实它们可以帮助你用一个完全不同的方式来建模。它们的作用比简化语法来得更深层次。事实上，它们完全从语意角度改变你解决问题的方式。</p>

<p>首先，我想先重温一下几年前写的一篇文章。它是关于 promises 是怎么在异步编程上作为一个 monad 的角色而存在的。这里的核心思想就是 monad 其实是帮助你组织函数的工具，比如说，当一个函数的返回值要做为下一个函数的输入的时候，建立数据管道。数据关系的结构化是实现的关键。</p>

<p>在这里的，我还是需要用到 Haskell 的类型注解来帮助说明一下。在 Haskell 里，注解 foo :: bar 表示 “foo 是 bar 的类型“。注解 foo :: Bar &ndash;> Qux 表示 “foo 是一个接受输入值为 Bar 类型和返回值为 Qux 类型的函数“。如果输入输出的类别并不重要的话，我们会用单一小写字母，foo :: a &ndash;> b。如果函数 foo 可以接受多个参数的化，我们会添加多个箭头，比如：“ foo :: a &ndash;> b &ndash;> c ” 表示 foo 接收两个分别为类型 a 和 b 的参数并返回类型 c 的值.</p>

<p>我们来看一个 Node 函数吧，比如，fs.readFile()。这个函数接收一个 String 类型的路径参数，还有一个回调函数，并且没有任何返回值。回调函数会接收一个可能为空的 Error 类型和一个包含了文件内容的 Buffer 类型的参数，并且也没有返回值。那我们就可以把 readFile 的类型用注解表示为:</p>

<p><code>haskell
readFile :: String -&gt; Callback -&gt; ()
</code></p>

<p>() 在 Haskell 注解中表示空值类型。这里的 callback 是另一个函数，它的注解可以表示为:</p>

<p><code>haskell
Callback :: Error -&gt; Buffer -&gt; ()
</code></p>

<p>把它们放在一起的话，我们可以说 readFile 接收两个参数，一个 String 类型，一个是接收 Buffer 参数的函数:</p>

<p><code>haskell
readFile :: String -&gt; (Error -&gt; Buffer -&gt; ()) -&gt; ()
</code></p>

<p>现在，我们来想象一下假如 Node 使用 promises 会是怎么样的。这样的情况下，readFile 可以简单的接收一个 String 类型参数然后返回一个 Buffer 的 promise:</p>

<p><code>haskell
readFile :: String -&gt; Promise Buffer
</code></p>

<p>一般来说，我们可以认为回调风格的函数接收一些参数和一个函数，这个函数将会被最终调用并传递返回值作为它的输入；promises 风格的函数就是接收一些参数，和返回一个带结果的 promise:</p>

<p><code>haskell
callback :: a -&gt; (Error -&gt; b -&gt; ()) -&gt; ()
promise :: a -&gt; Promise b
</code></p>

<p>那些回调风格返回的空值其实就是为什么使用回调风格来编程会很困难的根本原因: 回调风格不返回任何值，所以难以组合。一个没有返回值的函数执行的效果其实是利用它的副作用 – 一个没有返回值和利用副作用的函数其实就是一个黑洞。所以，使用回调风格来编程无法避免会是指令式的，它实际上是通过把一系列严重依赖于副作用的操作安排好执行顺序，而不是通过函数的调用来把输入输出值对应好。它是通过人手组织程序执行流程而不是靠理顺值的关系来解决问题的。这正是编写正确的并行程序困难的原因.</p>

<p>相反，基于 promise 的函数总是让你把函数返回值作为一个不依赖于时间的值来考虑的。当你调用一个回调风格的函数时，在你的函数调用和它的回调函数被调用之间，在程序里面我们没办法找到一个最终结果的表现形式.</p>

<p>```javascript
fs.readFile(&lsquo;file1.txt&rsquo;,
  // some time passes&hellip;
  function(error，buffer) {</p>

<pre><code>// the result now pops into existence
</code></pre>

<p>  }
);
```</p>

<p>从基于回调和事件的函数里面取得结果基本上意味着 “你必须在恰当的时间和地点”。如果你在事件被触发之后才绑定你的事件监听器，或者你没有在恰当的地方回调你的函数，那么恭喜你，你将无法得到你要的结果了。这些事情使得人们在 Node 里写 HTTP 服务器相当困难。如果你的控制流不对，你的程序就无法按期望运行.</p>

<p>相反，Promises 并不关心执行的顺序。你可以在 promise 兑现前或后注册监听器，但你总能拿到它的返回值。因此，那些马上返回的 promises 其实是给了你一个代表结果的值，让你可以把它当作一等公民，然后传递给其它函数。中间不需要等待一个回调或任何丢失事件的可能性。只要你手中拿着一个 promise 的引用，你就能从它得到你想要的值.</p>

<p>```javascript
var p1 = new Promise();
p1.then(console.log);
p1.resolve(42);</p>

<p>var p2 = new Promise();
p2.resolve(2013);
p2.then(console.log);</p>

<p>// prints:
// 42
// 2013
```</p>

<p>即便 then() 这个方法似乎隐含一些关于操作顺序 – 事实上这只是它的副作用 – 你可以把它想象成叫做 unwrap。Promise 是一个未知值的容器，那么 then 的工作就是从 promise 中把值取出来并交给另一个函数: 它其实是 monad 的 bind 函数。其实上面的代码里没有任何地方提及什么时候这个值是存在的，或事情是按照什么顺序发生的，它只是表达了一些依赖关系在里面: 你必须首先知道那个值是什么，然后才能够把它打印出来。程序的顺序是从值的依赖关系中衍生出来的。这里其实只有很小的区别，我们在后面讨论到延迟 promise 的时候会看得更清楚.</p>

<p>到目前为止，这些区别都很微小；很少函数单单和其它函数交互。我们现在来处理一些复杂一点的问题，以便看到 promises 更加强大之处。假设我们现在有一些代码，通过使用 fs.stat() 来取得一些文件的 mtimes。如果是同步的操作，我们只是需要调用 paths.map(fs.stat) 就可以了，但是因为用 mapping 来处理异步的问题是很困难的，我们看看用上 async 模块是什么样子.</p>

<p>```javascript
var async = require(&lsquo;async&rsquo;),</p>

<pre><code>fs    = require('fs');
</code></pre>

<p>var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;];</p>

<p>async.map(paths，fs.stat，function(error，results) {
  // use the results
});
```</p>

<p>(是的，我知道 fs 的函数有同步版本，但大多数涉及 I/O 的操作都没法这么做，就陪我玩一玩吧。)</p>

<p>这样看起来都还不错，直到我们决定要拿到 file1 的大小来做其它不相关的任务的时候。当然，我们可以再拿一次那个文件的状态:</p>

<p>```javascript
var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;];</p>

<p>async.map(paths，fs.stat，function(error，results) {
  // use the results
});</p>

<p>fs.stat(paths[0]，function(error，stat) {
  // use stat.size
});
```</p>

<p>这样显然没有问题，但是我们现在取了那个文件的状态两次。当然，本地的文件操作是没有问题的，但如果我们正在通过 https 来获取大文件的时候，那麻烦就大了。所以，我们只能访问文件一次。这样，我们就要修改一下前面的代码来特殊处理一下第一个文件:</p>

<p>```javascript
var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;];</p>

<p>async.map(paths，fs.stat，function(error，results) {
  var size = results[0].size;
  // use size
  // use the results
});
```</p>

<p>这初看也没有问题，但是获取文件大小的任务就必须等到整个列表都处理完了才能够开始。如果其中任何一个文件处理出错，我们就无法得到第一个文件的结果了。这种方案并不好，那我们来试一试另一种方式: 我们把第一个文件分开单独处理.</p>

<p>```javascript
var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;],</p>

<pre><code>file1 = paths.shift();
</code></pre>

<p>fs.stat(file1，function(error，stat) {
  // use stat.size
  async.map(paths，fs.stat，function(error，results) {</p>

<pre><code>results.unshift(stat);
// use the results
</code></pre>

<p>  });
});
```</p>

<p>这样当然可行，但是现在我们的程序并不是并行的了: 它将需要更长的时间去运行，因为我们必须等到第一个文件处理完才能开始处理那个列表里的文件。之前，它们都是同步进行的。还有，我们现在还必须对第一个文件特殊处理而引入一些数组的操作.</p>

<p>好吧，最后一击。我们现在要做的是得到所有文件的详情，每个文件只读取一次，如果第一个文件读取成功了我们要做些特殊处理，并且如果整个列表里的文件都处理成功，我们要对整个列表再进行一些操作。让我们用 async 来在代码里表达出这个需求的依赖关系看看.</p>

<p>```javascript
var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;],</p>

<pre><code>file1 = paths.shift();
</code></pre>

<p>async.parallel([
  function(callback) {</p>

<pre><code>fs.stat(file1，function(error，stat) {
  // use stat.size
  callback(error，stat);
});
</code></pre>

<p>  },
  function(callback) {</p>

<pre><code>async.map(paths，fs.stat，callback);
</code></pre>

<p>  }
]，function(error，results) {
  var stats = [results[0]].concat(results[1]);
  // use the stats
});
```</p>

<p>好了，这样就达到要求了: 每个文件只读取一次，所有的工作都是并行处理的，我们也可以独立的访问第一个文件的结果，并且相互依赖的任务都是尽早执行完毕的。搞定!</p>

<p>其实，并不能说完全搞定了。我认为这样的代码真的很丑陋，并且当问题变的复杂的时候，这样的代码很难扩展。为了让它正常工作，我们需要考虑大量的代码执行顺序问题。 而且设计意图并不明显以至于后面的维护很可能会不经意把它破坏掉。当我们引入了一个特殊需求后，原本问题的解决策略被迫同一些后续的跟进操作混杂在一起，并且我们还要对数组作出那么恶心的操作。</p>

<p>所有的问题其实都来自于我们尝试通过控制程序流来作为主要的解决问题的手段，而不是依赖于数据之间的关系。不是说 “为了能够运行这个任务，我需要这个数据”，并让运行环境去寻找优化手段，而是显式声明运行时什么应该并行，什么应该串行，所以导致我们的解决方案是如此脆弱.</p>

<p>那么，promises 如何改善这种情况呢? 我们需要一些操作文件系统的函数是可以返回 promises 而不是接收一个回调函数的。但是与其手写一个这样的函数，我们可以用元编程的方式写一个函数，使得它可以转换任何其它函数返回 promises。比如说，它可以接收如下一个函数定义为</p>

<p><code>haskell
String -&gt; (Error -&gt; Stat -&gt; ()) -&gt; ()
</code></p>

<p>并且返回以下类型</p>

<p><code>haskell
String -&gt; Promise Stat
</code></p>

<p>下面就是这个元编程的函数:</p>

<p>```javascript
// promisify :: (a &ndash;> (Error &ndash;> b &ndash;> ()) &ndash;> ()) &ndash;> (a &ndash;> Promise b)
var promisify = function(fn，receiver) {
  return function() {</p>

<pre><code>var slice   = Array.prototype.slice,
    args    = slice.call(arguments，0，fn.length - 1),
    promise = new Promise();

args.push(function() {
  var results = slice.call(arguments),
      error   = results.shift();

  if (error) promise.reject(error);
  else promise.resolve.apply(promise，results);
});

fn.apply(receiver，args);
return promise;
</code></pre>

<p>  };
};
```</p>

<p>(这还不是一个通用方案，但是足够在我们的场景里使用了.)</p>

<p>我们现在可以重新对我们的业务问题建模。我们基本上要做的就把一个列表的文件路径，转换为一个列表的文件状态 promises:</p>

<p>```javascript
var fs_stat = promisify(fs.stat);</p>

<p>var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;];</p>

<p>// [String] &ndash;> [Promise Stat]
var statsPromises = paths.map(fs_stat);
```</p>

<p>从这里就可以看出分别了: 通过使用 async.map() ， 你必须等到整个列表处理完了，你才能拿到数据进行处理。但是如果你有了一个列表的 promises，你可以直接拿第一个 promise 来操作:</p>

<p><code>javascript
statsPromises[0].then(function(stat) { /* use stat.size */ });
</code></p>

<p>所以，通过使用 promise，我们把大部分问题都解决了: 我们并行得到所有文件的状态，并且可以独立访问并不止第一个文件，可以是任何一个文件，而这只需要指定某个数组位就可以了。通过前一种方法，我们需要显式写逻辑特殊处理第一个文件，而且考虑怎么拿到那个文件还非常费事。但是，通过一个列表的 promises 就很容易了.</p>

<p>当然，这里缺少的部分是当所有的文件状态信息都拿到后，我们应该怎么处理。通过前面，我们得到了一个列表的 文件状态值对象，但这是一个列表的 promises。我们需要等到所有的 promises 都处理完后，拿到一个列表的文件状态。也就是说，我们要把一个列表的 promises 转化成一个 promise 对应于整个列表.</p>

<p>让我们看看一个简单的 list 方法是怎么做到可以把一个包含了 promises 的列表转化成一个 promise，而且当它里面所有的 promises 都处理完后，它自己也处理了.</p>

<p>```javascript
// list :: [Promise a] &ndash;> Promise [a]
var list = function(promises) {
  var listPromise = new Promise();
  for (var k in listPromise) promises[k] = listPromise[k];</p>

<p>  var results = []，done = 0;</p>

<p>  promises.forEach(function(promise，i) {</p>

<pre><code>promise.then(function(result) {
  results[i] = result;
  done += 1;
  if (done === promises.length) promises.resolve(results);
}，function(error) {
  promises.reject(error);
});
</code></pre>

<p>  });</p>

<p>  if (promises.length === 0) promises.resolve(results);
  return promises;
};
```</p>

<p><em>(译者注：这里感觉好像 promises 和 listPromise 几个地方反了。作者没开评论，无法确认，不过有时间试一下代码就知道了。)</em></p>

<p>(这个方法其实和 jQuery.when() 函数类似，它同样接收一个列表的 promises 并返回一个新的 promise。当这个 promise 所有的输入都处理完后，它自己也处理了.)</p>

<p>我们现在就可以通过把数组包装成一个 promise，然后等所有的处理结果出来就可以了:</p>

<p><code>javascript
list(statsPromises).then(function(stats) { /* use the stats */ });
</code></p>

<p>那么我们完整的解决方案就会是这样:</p>

<p>```javascript
var fs_stat = promisify(fs.stat);</p>

<p>var paths = [&lsquo;file1.txt'，'file2.txt'，'file3.txt&rsquo;],</p>

<pre><code>statsPromises = list(paths.map(fs_stat));
</code></pre>

<p>statsPromises[0].then(function(stat) {
  // use stat.size
});</p>

<p>statsPromises.then(function(stats) {
  // use the stats
});
```</p>

<p>这个解决方案的表达就相当的简洁清晰了。通过一些通用的辅助函数和既有的数组操作函数，我们用一种正确的，有效并且容易调整的方法来实现了。我们也不需要 async 模块的特殊集合类函数，我们只需要让 promises和数组两者的思想相互独立，并通过一种强大的方式把它们组合使用就可以了.</p>

<p>特别要注意的是，我们的程序在这里并没有说任何部分是应该是并行还是串行处理的。我们只是描述了我们想要什么，任务之间的关系是怎么样的，剩下的都是 promise 组件帮我们优化的.</p>

<p>事实上，很多在 async 的集合类模块可以很容易用一个列表的 promises 来替代。我们已经看到过 map 是怎么工作的了; 下面的代码:</p>

<p><code>javascript
async.map(inputs，fn，function(error，results) {});
</code></p>

<p>和下面的是一样的:</p>

<p>```javascript
list(inputs.map(promisify(fn))).then(</p>

<pre><code>function(results) {},
function(error) {}
</code></pre>

<p>);
```</p>

<p>async.each() 其实就是用 async.map()，然后利用那些被执行的函数的副作用，而把它们的返回值舍弃掉; 你用 map() 就可以了.</p>

<p>async.mapSeries() (如前所述，async.eachSeries()) 其实就是对一个列表的 promises 上调用 reduce()。那就是，它你的输入列表，使用 reduce 来得到一个依赖于前面 promise 的操作成功后再执行的 promise。我们来举个例子: 实现一个基于 fs.rmdir() 的程序来实现和 rm -rf 相同的功能。下面的代码:</p>

<p><code>javascript
var dirs = ['a/b/c'，'a/b'，'a'];
async.mapSeries(dirs，fs.rmdir，function(error) {});
</code></p>

<p>和下面的是一样的:</p>

<p>```javascript
var dirs     = [&lsquo;a/b/c'，'a/b'，'a&rsquo;],</p>

<pre><code>fs_rmdir = promisify(fs.rmdir);
</code></pre>

<p>var rm_rf = dirs.reduce(function(promise，path) {
  return promise.then(function() { return fs_rmdir(path) });
}，unit());</p>

<p>rm_rf.then(</p>

<pre><code>function() {},
function(error) {}
</code></pre>

<p>);
```</p>

<p>这里的 unit() 只是一个简单的返回一个已经处理的 promise 来开始整个操作链 (如果你知道什么是 monads，这个就是 promises 的返回函数):</p>

<p><code>javascript
// unit :: a -&gt; Promise a
var unit = function(a) {
  var promise = new Promise();
  promise.resolve(a);
  return promise;
};
</code></p>

<p>这个使用 reduce() 的方案简单的使用接收列表中的两个路径值，并使用 promise.then() 来确保前面的文件夹删除成功之后，再删除后面的文件夹。这其实还帮你处理了非空文件夹的情况: 如果前面的 promise 因为任何错误而无法处理，那么整个处理流程就停止了。使用值的依赖关系来强制某种执行顺序是函数式编程使用 monads 来处理副作用的核心思想.</p>

<p>最后的代码似乎比同样功能的 async 代码更啰嗦，但别因为这样蒙骗了你。最重要的思想是我们通过使用 promise 数值和列表操作来组合程序，而不是依赖于特别的库来控制程序流。正如我们前面看到的，前一种方式可以写出更容易理解的程序.</p>

<p>前一种程序更容易理解是因为我们把我们思考流程的一部分交给机器去做了。当使用 async 模块的时候，我们的思考流程是这样的:</p>

<ol type="a">
<li>在程序里，我们的任务应该是这样相互依赖的,</li>
<li>因此，应该要这样把操作组织好,</li>
<li>那么，我们现在用代码来表现 B 所描述的流程.</li>
</ol>


<p>利用相互依赖的 promises 可以让你完全把 B 那步抛弃掉。你的代码只需要表达出任务的相互关系就可以了，然后让电脑来决定处理流程。换另一个说法就是，回调风格是显式的控制处理流程来把很多值组织在一起，而 promises 是显式表达出值的关系来把控制流的各个组件连接在一起。回调是指令式的，promises 是函数式的.</p>

<p>这个主题的讨论只有当我们谈到 promises 的最后一个使用场景，也就是函数式编程的核心思想，延时性，才算完整。Haskell 是一种惰性语言。它和那些从上往下执行的脚本程序不一样，它是从定义了程序最终输出的表达式开始的 – 有什么需要写到标准输出，数据库等，然后反回来向前执行。它首先看最终的表达式是依赖哪些表达式来取得它们的输入值的，然后一直往前遍历整棵树图，直到整个程序为了它的输出结果反过来计算出所需的所有数据为止。只有需要用到的数据才会在程序里计算出来.</p>

<p>很多时候，计算机领域的问题，最后找到的最佳解决方案都是需要找到最佳的数据结构来建模而得出来的。JavaScript 里有一个跟我刚才描述的情况非常相似的问题: 模块加载。你只想加载那些你的程序需要用到的模块，并且希望越快越好.</p>

<p>在我们有 CommonJS 和 AMD 这类有了依赖关系意识的规范前，我们有好一些脚本加载库。它们基本的工作原理都是像我们上面的例子一样，通过显式向加载器声明你要加载的脚本哪些是可以并行下载的，哪些是一定要按某种顺序下载。你基本上都要说清楚下载的策略，要正确并有效的做好的是相当困难的。相反，通过描述脚本之间的依赖关系来让加载器优化下载策略就会容易很多.</p>

<p>现在让我们来看看怎么实现 LazyPromise 的。这是一个 Promise，包含了一个可能会做异步操作的函数。这个函数只有在被调用 then() 这个方法的时候会被执行一次: 我们只有在有需要得到返回结果的时候才会开始执行。我们通过重写 then() 来判断一下如果还没有开始过的话就执行操作.</p>

<p>```javascript
var Promise = require(&lsquo;rsvp&rsquo;).Promise,</p>

<pre><code>util    = require('util');
</code></pre>

<p>var LazyPromise = function(factory) {
  this.<em>factory = factory;
  this.</em>started = false;
};
util.inherits(LazyPromise，Promise);</p>

<p>LazyPromise.prototype.then = function() {
  if (!this._started) {</p>

<pre><code>this._started = true;
var self = this;

this._factory(function(error，result) {
  if (error) self.reject(error);
  else self.resolve(result);
});
</code></pre>

<p>  }
  return Promise.prototype.then.apply(this，arguments);
};
```</p>

<p>比如说，下面这个程序什么也不会做: 因为我们没有向 promise 取值，没有需要执行任何操作:</p>

<p>```javascript
var delayed = new LazyPromise(function(callback) {
  console.log(&lsquo;Started&rsquo;);
  setTimeout(function() {</p>

<pre><code>console.log('Done');
callback(null，42);
</code></pre>

<p>  }，1000);
});
```</p>

<p>但是如果我们添加了下面这一行代码，那么程序就会打印出 Started，然后一秒后再打印出Done，最后打印出42:</p>

<p><code>javascript
delayed.then(console.log);
</code></p>

<p>因为中间的异步操作是只处理一次的，所以调用 then() 多次会打印最终结果多次，但不会每次再执行异步操作:</p>

<p>```javascript
delayed.then(console.log);
delayed.then(console.log);
delayed.then(console.log);</p>

<p>// prints:
// Started
// &mdash; 1 second delay &mdash;
// Done
// 42
// 42
// 42
```</p>

<p>通过把以上简单的通用操作抽象出来，我们很容易就可以打造一个模块优化系统。想象一下我们要把一系列的模块这样处理一下: 每一个模块创建时都绑定了一个名字，一个它依赖的模块列表，和一个构造函数。这个构造函数会在执行时被传入所依赖的模块作为参数，然后返回本身这个模块的 API。这其实和 AMD 工作模式类似.</p>

<p>```javascript
var A = new Module(&lsquo;A'，[]，function() {
  return {</p>

<pre><code>logBase: function(x，y) {
  return Math.log(x) / Math.log(y);
}
</code></pre>

<p>  };
});</p>

<p>var B = new Module(&lsquo;B'，[A]，function(a) {
  return {</p>

<pre><code>doMath: function(x，y) {
  return 'B result is: ' + a.logBase(x，y);
}
</code></pre>

<p>  };
});</p>

<p>var C = new Module(&lsquo;C'，[A]，function(a) {
  return {</p>

<pre><code>doMath: function(x，y) {
  return 'C result is: ' + a.logBase(y，x);
}
</code></pre>

<p>  };
});</p>

<p>var D = new Module(&rsquo;D'，[B，C]，function(b，c) {
  return {</p>

<pre><code>run: function(x，y) {
  console.log(b.doMath(x，y));
  console.log(c.doMath(x，y));
}
</code></pre>

<p>  };
});
```</p>

<p>现在我们有了一个钻石模型图: D 依赖于 B 和 C，而它们两个又依赖于 A。这就意味着我们可以加载 A，然后并行加载 B 和 C，当 B 和 C 都加载完后，我们就可以加载 D 了。但是，我们希望我们的工具可以帮我们计算出来，而不是我们自己来实现这个策略.</p>

<p>我们可以通过把模块建模为 LazyPromise 的子类后很容易的实现。它的构造函数可以通过使用前面的列表 promise 辅助函数来取得它的依赖模块，然后在某一个延时后创建这些依赖模块来模拟异步加载的延时效果.</p>

<p>```javascript
var DELAY = 1000;</p>

<p>var Module = function(name，deps，factory) {
  this._factory = function(callback) {</p>

<pre><code>list(deps).then(function(apis) {
  console.log('-- module LOAD: ' + name);
  setTimeout(function() {
    console.log('-- module done: ' + name);
    var api = factory.apply(this，apis);
    callback(null，api);
  }，DELAY);
});
</code></pre>

<p>  };
};
util.inherits(Module，LazyPromise);
```</p>

<p>因为 Module 是一个 LazyPromise，单纯定义模块并不会加载任何东西回来。只有当我们需要开始使用的时候，加载才会执行:</p>

<p>```javascript
D.then(function(d) { d.run(1000，2) });</p>

<p>// prints:
//
// &mdash; module LOAD: A
// &mdash; module done: A
// &mdash; module LOAD: B
// &mdash; module LOAD: C
// &mdash; module done: B
// &mdash; module done: C
// &mdash; module LOAD: D
// &mdash; module done: D
// B result is: 9.965784284662087
// C result is: 0.10034333188799373
```</p>

<p>正如你所见到的，A 首先加载，当它完成后 B 和 C 开始同时下载，然后当它们都加载完后  D 开始加载，正如我们想要的那样。如果你只是执行 C.then(function() {})，你可以看到只有 A 和 C 加载; 关系图里没需要用到的是没有加载的.</p>

<p>所以，基本上不需要太多代码，只需要定义好懒 promises 的关系图，我们就实现了一个正确的模块加载器。我们使用的是函数式编程里面的定义值的依赖关系这种方式，而不是显式控制程序执行顺序的方式来解决问题，并且这种方式比起自己控制执行流程更加容易。你可以给出任何非循环依赖关系图来让这个模块加载库帮你优化执行顺序.</p>

<p>这才是 promises 的真正强大之处。它们并不仅仅从语法层面减少代码嵌套。它们让你再更高的层面来为你的问题抽象建模，和让你的工具帮你做更多的工作。事实上，那应该是我们必须向我们的软件提出的要求。如果 Node 真的希望把并行编程更容易的话，它们应该重新考虑一下 promises.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Share code between Node.js and browser]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/04/13/share-code-between-nodejs-and-browser/"/>
    <updated>2013-04-13T12:59:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/04/13/share-code-between-nodejs-and-browser</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>When you are writing a Node.js based web application, it comes to a demand to share code between Node.js and browser because both the frontend and backend are written in JavaScript.  Some utility APIs, such as validation, data processing, are the common cases.</p>

<p>The philosophy of organizing code in Node.js, current trend also, is modularization.  Each module file has its own execution context, requires its dependent APIs from other modules and publishes its own APIs out for other modules.</p>

<p>Hence, the code sharing between Node.js and browser requires the code to be used as the same way in browser.</p>

<h2>Situations and Solutions</h2>

<p>Things work differently regarding the JS and modules loading mechanism.  Because in browser, it works asynchronously while in Node.js it is synchronous.  In browser, we cannot directly do inline require like Node.js:</p>

<p>```javascript
var a = xxx;
a.foo();</p>

<p>var b = require(&lsquo;b&rsquo;);
b.bar();
```</p>

<p>There are two kinds of situations:</p>

<h3>Modularization already realized for browser code</h3>

<p>If you have already modularized your JS code for browser and used some AMD / CMD script loader, such as <a href="http://requirejs.org/">RequireJS</a>, or <a href="http://seajs.org/">SeaJS</a>, you might expect your life would be easier.  However, this is not the case.</p>

<p>The require must be like below in order to make sure all dependent modules to be loaded successfully and then execute the code which uses them.</p>

<p>```javascript
define([&lsquo;./b&rsquo;], function (b) {</p>

<pre><code>var a = xxx;
a.foo();
b.bar();

return {
    bla: function(){
        console.log('bla');
    }
};
</code></pre>

<p>});
```</p>

<p>We can see that there is quite some syntax different between Node.js style and the AMD / CMD one in browser.</p>

<p>To overcome this incompatibility, there are two main approaches.</p>

<ul>
<li><p>Directly add boilerplate code in one side to fit the other</p>

<ol>
<li> Some sample manual boilerplate code and also more explanation can be found <a href="http://www.2ality.com/2011/11/module-gap.html">here</a>.</li>
<li> <a href="https://github.com/ajaxorg/node-amd-loader">node-amd-loader</a>: Add one extra line in Node.js module to load AMD style module.</li>
<li> The <a href="https://github.com/jrburke/amdefine">amdefine</a> for RequireJS: Special boilerplate code in Node.js module and then can be stripped out by <a href="https://github.com/jrburke/amdefine#optimizer">RequireJS Optimizer</a>.</li>
</ol>
</li>
<li><p>Build process to handle the boilerplate</p>

<ol>
<li> <a href="https://github.com/substack/node-browserify">browserify</a>: Recursively analyze all the <code>require()</code> calls in your app in order to build a bundle you can serve up to the browser in a single <code>&lt;script&gt;</code> tag.</li>
<li> <a href="https://github.com/medikoo/modules-webmake">modules-webmake</a>: Bundle CommonJS/Node.js modules for web browsers.</li>
<li> <a href="https://github.com/kenspirit/webassemble">webassemble</a>: Based on modules-webmake.  Auto bundle CommonJS/Node.js packages for web browsers.</li>
</ol>
</li>
</ul>


<p>Personally, I prefer introducing extra build process to handle the boilerplate for me.</p>

<p>The advantages of build process boilerplate are:</p>

<ol>
<li>Boilerplate code is brittle and subject to change.  Adding it to every file makes future change harder.  If some build process can automatically remove them, why not use the build process to automatically add them?</li>
<li>Modularization is good but for production environment in browser, it is always better to minimize network request to load JS file.  Most of the time, module files are bundled into single package for one call.  If build process need to be introduced to handle it, it would be great to integrate sharing logic into it also.</li>
<li>If the boilerplate is introduced in build process, it is better to discover potential error during development cycle instead of last minute preproduction testing.</li>
</ol>


<p>You may have concern on effectiveness during development cycle.  However, if you can make good use of a good IDE, say <a href="http://www.sublimetext.com/">Sublime Text</a> and some task runner, say <a href="http://gruntjs.com/">Grunt</a>, it&rsquo;s just a couple of seconds' waiting after a hotkey command after saving your JS file in IDE.  It might just be the time you switch from IDE to browser and press F5.</p>

<h3>Legacy or namespace browser code style</h3>

<p>Although it&rsquo;s seldom the case that when you are using such hot tech of Node.js but still need to stick to the old style in browser, it&rsquo;s actually easier to share your Node.js code under this circumstance.</p>

<p>The webmake and webassemble mentioned above is easy to bundle your modules under global or a particular namespace.</p>

<p>So, what is my favorite choice?  Write the Node.js style code and share them to browser by webassemble.  Why not webmake?  Because the webassemble is made by me. :P</p>

<p>So tell me what is yours.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A response pends forever issue in MongoDB, Connect and Node.js]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/12/05/a-response-pends-forever-issue-in-mongodb-connect-and-nodejs/"/>
    <updated>2012-12-05T21:08:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/12/05/a-response-pends-forever-issue-in-mongodb-connect-and-nodejs</id>
    <content type="html"><![CDATA[<p><strong>My ignorance</strong><br/>
When I first switched to use <a href="https://github.com/masylum/connect-mongodb">connect-mongodb</a> to replace the MemoryStore in <a href="https://github.com/senchalabs/connect">Connect</a>, I found that the homepage of my pet project cannot be even loaded and it seems the response is kept waiting there.  If I switched back to use MemoryStore, it&rsquo;s all fine.  There must be something wrong when I am using <a href="http://www.mongodb.org/">MongoDB</a> for session management.</p>

<p>First, I dig into the <em>session.js</em> in Connect.  Around line 267:
```javascript connect/lib/middleware/session.js</p>

<pre><code>// proxy end() to commit the session
var end = res.end;
res.end = function(data, encoding){
  res.end = end;
  if (!req.session) return res.end(data, encoding);
  debug('saving');
  req.session.resetMaxAge();
  req.session.save(function(){
    debug('saved');
    res.end(data, encoding);
  });
};
</code></pre>

<p>```</p>

<p>After opening the debug feature in <a href="http://nodejs.org">Node</a>, I found that it&rsquo;s never going into the callback of <em>session.save()</em>.  Hence, the &lsquo;saved&rsquo; message is never printed in the console after &lsquo;saving&rsquo; and the response is never ending.</p>

<p>Why would this happened?  I kept tracing the code and found that <em>session.save()</em> in Connect is calling the <em>sessionStore.set()</em> method.  The <em>MongoStore.set()</em> method in <em>connect-mongodb.js</em> is just purely calling <em>collection.update()</em> and no much magic there.  However, it seems the <em>update()</em> method call has either no err and data coming back.  Is there something wrong with the MongoDB or the Collection?</p>

<p>MongoDB log doesn&rsquo;t seems to have any query or update action recorded and I just found that there are 10 connections started every time I started my app, but I remembered there were 5 connections (default pool size) before (Actually, I haven&rsquo;t noticed that this is the phenomenon of the problem I have at that time yet).</p>

<p>Without any clue, I checked the initialization of the MongoStore and find below code:
```javascript</p>

<pre><code>if (server_config.isConnected()) {
  authenticateAndGetCollection(callback);
} else {
  server_config.connect(db, function (err) {
    if (err) callback(Error("Error connecting (" + (err instanceof Error ? err.message : err) + ")"));
      authenticateAndGetCollection(callback);
    });
}
</code></pre>

<p>```</p>

<p>It turns out that the flow goes into <em>server_config.connect()</em> again.  But why?  DB should be initialized in below code which is intended to encapsulate all DB operation.
```javascript DbManager.js</p>

<pre><code>DbManager = (function() {
  var db = new Db('tyt', new Server('127.0.0.1', 27017, {auto_reconnect: true}, {}), {safe: true});
  db.open(function(){});

  return {
    getDb: function() {
        return db;
    }
  }
})();

exports.DbManager = DbManager;
</code></pre>

<p>```</p>

<p>```javascript In my node app.js</p>

<pre><code>var express = require('express')
  , DbManager = require('./db.js').DbManager
  , mongoStore = require('connect-mongodb');

var app = module.exports = express();

// Configuration
app.configure(function(){
  app.use(express.session({
      secret: 'kenspirit',
      key: 'tt.sid',
      cookie: {secure: false, maxAge: 300000},
      store: new mongoStore({db: DbManager.getDb()})
  }));
});
</code></pre>

<p>```</p>

<p>If you are familiar with Node, you may have already noticed what I haven&rsquo;t done right here.  I am assuming the DB should be connected and ready for use already as I have called <em>db.open()</em> during DbManager&rsquo;s construction.  However, Async is the most importance concept in Node, <em>db.open()</em> takes my callback will immediately return and it doesn&rsquo;t guarantee it&rsquo;s opened already.  If I change to below code, problem solved.</p>

<p>```javascript</p>

<pre><code>var db = DbManager.getDb();
db.open(function(err, db) {
  if (db) {
    app.use(express.session({
      secret: 'kenspirit',
      key: 'tt.sid',
      cookie: {secure: false, maxAge: 300000},
      store: new mongoStore({db: db})
    }));
   }
});
</code></pre>

<p>```</p>

<p><strong>The root of not responding</strong><br/>
I wonder where is the actual source to make the response kept waiting?  I have configured the <em>auto_reconnect</em> already.  Later I found that in mongodb:
```javascript mongodb/lib/mongodb/db.js
  Db.prototype.open = function(callback) {</p>

<pre><code>...
self._state = 'connecting';
...
self.serverConfig.connect(self, {firstCall: true}, function(err, result) {
  if(err != null) {
    // Set that db has been closed
    self.openCalled = false;
    // Return error from connection
    return callback(err, null);
  }
  // Set the status of the server
  self._state = 'connected';
  // Callback
  return callback(null, self);
});
...
</code></pre>

<p>  };</p>

<p>  Db.prototype._executeInsertCommand = function(db_command, options, callback) {</p>

<pre><code>...
// If the pool is not connected, attemp to reconnect to send the message
if(self._state == 'connecting' &amp;&amp; this.serverConfig.autoReconnect) {
  process.nextTick(function() {
    self.commands.push({type:'insert', 'db_command':db_command, 'options':options, 'callback':callback});
  })
}
...
</code></pre>

<p>  ;}
```</p>

<p>```javascript mongodb/lib/connection/server.js
  Server.prototype.connect = function(dbInstance, options, callback) {</p>

<pre><code>...
// Force connection pool if there is one
if(server.connectionPool) server.connectionPool.stop();
...
// Create connection Pool instance with the current BSON serializer
var connectionPool = new ConnectionPool(this.host, this.port, this.poolSize, dbInstance.bson,  this.socketOptions);
...
// Set up on connect method
connectionPool.on("poolReady", function() {
  // Create db command and Add the callback to the list of callbacks by the request id (mapping outgoing messages to correct callbacks)
  var db_command = DbCommand.NcreateIsMasterCommand(dbInstance, dbInstance.databaseName);
  // Check out a reader from the pool
  var connection = connectionPool.checkoutConnection();
  // Set server state to connEcted
  server._serverState = 'connected';
  // dbInstance._state = 'connected';  If I add this line here, even if my code doesn't do any change, it works.
  ...
});
</code></pre>

<p>  };
```</p>

<p>Finally, the root cause is found.  Normally, when <em>db.open()</em> is called, it sets its <em>_state = &lsquo;connecting&rsquo;</em>, and it then will call <em>server.connect()</em> to create connection pool and in the callback, it sets its <em>_state = &lsquo;connected&rsquo;</em> again.  However, my case is that the second call <em>server.connect()</em> in MongoStore.js first make the first connection pool stops and then creates a new connection pool again(This should be where makes the mongo db log has 10 connections opened).  Somehow, the callback in normal flow cannot be executed so that <em>db._state</em> has not been set to &lsquo;connected&rsquo;.  What is more, the callback set in <em>MongoStore.js</em> doesn&rsquo;t set the <em>db._state</em> to &lsquo;connected&rsquo;.  The <em>db._state</em> is remained in &lsquo;connecting&rsquo; forever which makes my update command keep pushing to its commands stack.</p>

<p><strong>Most appropriate way to initialize MongoDB and its connections in Node.js</strong><br/>
I began to wonder what is the &ldquo;most appropriate way&rdquo; to initialize MongoDB and manage its connections and googled around.</p>

<p>At first, I found a similar question asked in <a href="http://stackoverflow.com/questions/10656574/how-to-manage-mongodb-connections-in-a-nodejs-webapp">StackOverFlow</a>.<br/>
However, the reply doesn&rsquo;t seem to be reasonable.  It recommands opening a new connection (actually, a DB and Connection Pool there) per request.  And it said it&rsquo;s due to MongoDB is asynchronous.  It&rsquo;s pretty confusing and the asynchronous mechanism in Node should be achieved by callback instead of creating new connection per request.  If so, what is the point of using pool then?  This approach should be more slow.</p>

<p>Later I found out a reply from the author of node-mongodb-native in <a href="http://stackoverflow.com/questions/10307994/where-can-i-find-complete-documentation-concerning-node-mongodb-native/10349450#10349450">StackOverFlow</a> too.  It clearly stated &ldquo;DO NOT call open on each request.&rdquo;.</p>

<p>I believe only opening MongoDB once with appropriate pool size and initialize node application in the <em>db.open()</em> callback should be the right way to go.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS, Jasmine, Maven - Integration]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2012/08/06/extjs-jasmine-maven-integration/"/>
    <updated>2012-08-06T22:59:31+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2012/08/06/extjs-jasmine-maven-integration</id>
    <content type="html"><![CDATA[<p>After briefing <a href="http://www.thinkingincrowd.me/blog/2012/08/05/extjs-jasmine-maven-why-i-am-working-on-them/">Why I am working on them</a>, let me show you how they can be integrated all together first.</p>

<p><a href="http://pivotal.github.com/jasmine/">Jasmine</a> is a BDD Test Framework which can be integrated in many environments.  At first, I want to integrate it with <a href="http://nodejs.org/">NodeJS</a> which I have been eager to use for a long time.  However, when using NodeJS in Windows environment, I encountered some strange error &ldquo;Class not found: File&rdquo; if I tried to start my local Weblogic server.  After I removed NodeJS installation path from environment variable PATH, the error is gone.</p>

<p>The other reason I decided not integrating Jasmine in NodeJS in our project is because it might be difficult for some people to learn a completely new stuff and it is also not compatible to our JAVA development environment &amp; process.  <a href="maven.apache.org">Maven</a> is a better choice for us now because we should be using it for our project&rsquo;s build management.</p>

<p>Let&rsquo;s see how it can be done.  Here, I assume you already know what Maven is and have your own project POM.xml.  Then, simply setup <a href="https://github.com/searls/jasmine-maven-plugin">jasmine-maven-plugin</a> in your POM.xml like below.</p>

<p>```xml</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.searls&lt;/groupId&gt;
    &lt;artifactId&gt;jasmine-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.2.0.0&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;test&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
    &lt;preloadSources&gt;
        &lt;source&gt;${project.basedir}/[SOME_PRELOAD_FILES_GOES_HERE]&lt;/source&gt;
    &lt;/preloadSources&gt;
    &lt;jsSrcDir&gt;${project.basedir}/Resources/js&lt;/jsSrcDir&gt;
    &lt;jsTestSrcDir&gt;${project.basedir}/Resources/test/js&lt;/jsTestSrcDir&gt;
    &lt;sourceIncludes&gt;
            &lt;include&gt;[TO_BE_TESTED_JS_FILES_GOES_HERE]&lt;/include&gt;
        &lt;include&gt;[TO_BE_TESTED_JS_FOLDER_GOES_HERE]/*.js&lt;/include&gt;
    &lt;/sourceIncludes&gt;
    &lt;specIncludes&gt;
        &lt;include&gt;[SPEC_JS_FOLDER_GOES_HERE]/*.js&lt;/include&gt;
    &lt;/specIncludes&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>```</p>

<p>After you modify those CAPITALIZED PLACEHOLDER to fit your own project, you can simply type &ldquo;mvn test&rdquo; in command line to see whether Jasmine is included into your Maven test lifecycle.  You should have something similar in output:</p>

<p>```bash</p>

<pre><code>[INFO] Executing Jasmine Specs
-------------------------------------------------------
 J A S M I N E   S P E C S
-------------------------------------------------------
[INFO]
Test Suite Name 1
  Spec 1
  Spec 2

Test Suite Name 2
  Spec 3

Results: 3 specs, 0 failures
</code></pre>

<p>```</p>

<p>If you encounter any error, please go check the documentation site of this plugin or leave a comment here.  The plugin setup should be quite strange forward.</p>

<p>File path in <em>sourceIncludes</em>, <em>specIncludes</em> are relative paths to <em>jsSrcDir</em> and <em>jsTestSrcDir</em>.  <em>preloadSources</em>, <em>sourceIncludes</em>, <em>specIncludes</em> are treated as ordered list so that you can properly arrange your JS and Jasmine Spec in correct order when your JS or Spec has some loading dependency.</p>

<p>OK, now preparation for Unit Test is done.  Let&rsquo;s see how Jasmine can be used to do Unit Test especially for ExtJS project together in my next post.</p>
]]></content>
  </entry>
  
</feed>
