<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Mocha | Thinking in Crowd / 鹄思乱想]]></title>
  <link href="http://www.thinkingincrowd.me/tags/mocha/atom.xml" rel="self"/>
  <link href="http://www.thinkingincrowd.me/"/>
  <updated>2014-03-30T09:44:43+08:00</updated>
  <id>http://www.thinkingincrowd.me/</id>
  <author>
    <name><![CDATA[鹄思乱想]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to use Ext Ajax in Promise style and test it]]></title>
    <link href="http://www.thinkingincrowd.me/blog/2013/11/25/how-to-use-ext-ajax-in-promise-style-and-test-it/"/>
    <updated>2013-11-25T08:50:00+08:00</updated>
    <id>http://www.thinkingincrowd.me/blog/2013/11/25/how-to-use-ext-ajax-in-promise-style-and-test-it</id>
    <content type="html"><![CDATA[<p>After translated a <a href="http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/">blog</a> about how Promise works in a more functional programming way, I tried to build something to make Ext Ajax call to work in Promise style as a practice.</p>

<p><a href="https://github.com/kenspirit/ExtPromise">ExtPromise</a> is a simple wrapper to Ext.Ajax and Ext.data.Connection to help you do an Ajax call in Promise style instead of passing success/failure callback to it.  The Promise library I used is the <a href="https://github.com/petkaantonov/bluebird">bluebird</a>.  I chose it not only because its speed is faster than most of the Promise library, but also its error handling philosophy looks cleaner and more attractive.</p>

<p>It didn&rsquo;t took long to implement the ExtPromise wrapper but it took me some time to test it.</p>

<p>Originally, I thought I could use the <a href="http://www.thinkingincrowd.me/blog/2012/08/30/extjs-jasmine-unit-test-part-2-ajax-behavior-2/">jasmine-ajax</a> I enhanced and shared before about how to test Ajax call in ExtJs.  However, it doesn&rsquo;t work as expected.  Testing Async method in <a href="http://pivotal.github.com/jasmine/">Jasmine</a> seems very awkward because the API in version 1.4 and 2.0 are dramaticlly different.  Even worst, many strange issues messed around all the way.</p>

<p>I finally gave up and search other alternative approaches.  <a href="http://github.com/cjohansen/Sinon.JS">Sinon.js</a> and <a href="http://github.com/visionmedia/mocha/">Mocha</a> come to rescure.  It is pretty easy to test the Ajax call using the <code>useFakeXMLHttpRequest</code> provided by Sinon and the Async testing in Mocha looks more intuitive (Jasmine 2.0 use the same way).  Let&rsquo;s see how the testing (BDD style) is setup.</p>

<p>```javascript
describe(&ldquo;Ajax should be now working in promise style&rdquo;, function() {</p>

<pre><code>var xhr, ajax;

before(function() {
    xhr = sinon.useFakeXMLHttpRequest();
    xhr.onCreate = function(xhr) {
        ajax = xhr;
    }
})

after(function() {
    xhr.restore();
});

describe('ExtPromise.Ajax', function() {
    it("#success case", function(done) {
        ExtPromise.Ajax().request({url: 'foo'})
        .then(function(result) {
            expect(result.responseText).to.equal('Bar');
            done();
        })
        .catch(done);

        ajax.respond(200, { 'Content-Type': 'application/json' }, 'Bar');
    });
});
</code></pre>

<p>});
```</p>

<p>It&rsquo;s quite straightforward.  Before test spec runs, it&rsquo;s required to stub the XMLHttpRequest using Sinon&rsquo;s <code>useFakeXMLHttpRequest</code> API and obtain a reference in the <code>onCreate</code> method so that later it can be used to stub a response.</p>

<p>Passing a <code>done</code> parameter in the test spec function tells Mocha that this spec is for Async testing and callinig <code>done()</code> will end it.  One thing to notice here is this part.</p>

<p>```javascript</p>

<pre><code>.catch(done);
</code></pre>

<p>```</p>

<p>If you don&rsquo;t do this, and the assertion in the test spec failed, the error it shows will be a timeout error instead of telling the true assertion error.</p>

<p>When testing failure case, the style written like below doesn&rsquo;t look good and error-prone because <code>done()</code> is called twice although you might think the success resolver doesnot require as it should not be called.</p>

<p>```javascript</p>

<pre><code>ExtPromise.Ajax().request({url: 'foo', scope: scopeObj})
    .then(scopeObj.getName)
    .then(function(result) {
        expect(result).to.equal('Bar In scope');
        done();
    }, function(result) {
        expect(result.status).to.equal(500);
        done();
    })
    .catch(done);

ajax.respond(500, { 'Content-Type': 'application/json' }, 'Error');
</code></pre>

<p>```</p>

<p>You may rewrite the call to <code>done</code> in a then call.</p>

<p>```javascript</p>

<pre><code>ExtPromise.Ajax().request({url: 'foo', scope: scopeObj})
    .then(scopeObj.getName)
    .then(function(result) {
        expect(result).to.equal('Bar In scope');
    }, function(result) {
        expect(result.status).to.equal(500);
    })
    .then(done)
    .catch(done);

ajax.respond(500, { 'Content-Type': 'application/json' }, 'Error');
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
